# 沙堆模型

本文告诉大家一个简单的模型，这个模型是用来说明在一个大的团队，如何才能有效让团队组成在添加成员时，总体降低。

<!--more-->
<!-- csdn -->

这个模型是我从逻辑里面看到，在复杂的组合，可能因为一个新的成员加入，让整个团队开始变成负面

本文里面存在大量的计算，虽然我尽量把文章写的很简单，但是这个算法本身不是那么好理解。最关键的就在于算法本身，请不要问我为什么这个算法需要这样算，因为都是我定义的。

## 正面属性负面属性

对于任意的属性，都可以作为正面和负面表示。

数学本身是没有意义，给数学现实的计算才有意义，为了让大家能够简单的看懂，我把下面的算法用写游戏的方式告诉大家。

很久之前，听了研究院的院长说，人工智能就是一个炼药的过程，放入一些数据，然后等，最后会发生什么是没人知道。

所以我也就把下面这个游戏叫做炼药师。

对于炼药师，他需要了解很多的材料，每个材料都有正面属性和负面属性。

如材料1 正面属性是 增加生命力，负面属性是降低魔力。

材料2 正面属性是 增加魔力，负面属性是降低力量。

## 材料相加

这里需要重新定义加法，两个材料相加会变成新的材料。

两个相加的材料的最终效果是正面属性相加、负面属性相加。如果正面属性或负面属性有相同的作用，那么两个相同的作用就可以使用数值的加法相加。

如下面的两个材料

材料 1

```csharp
正面属性

生命力 1.0

负面属性

魔力 2.1
```

材料 2

```csharp
正面属性

魔力 2.2

负面属性

力量 0.1
```

那么材料1+材料2的第一步计算请看下面


材料1 的正面属性和材料2的正面属性相加，如果有相同的效果，把相同效果进行数值相加。材料1的负面属性和材料2相加，和正面属性相加的计算方式相同。

材料1+材料2

```csharp
正面属性

生命力 1.0

魔力 2.2 

负面属性

魔力 2.1

力量 0.1
```

第二步计算是找到正面属性和负面属性同时存在的效果，使用正面属性的效果的值减去负面属性的效果。然后去掉负面属性中和正面属性相同的效果。

从 材料1+材料2 的上一步，可以找到存在正面属性的 魔力值和负面属性的魔力值，把两个值相减。从负面属性去掉魔力

这时计算材料1+材料2的魔力值 2.2-2.1=0.1，最后计算出来材料1+材料2的材料3

材料3


> 正面属性

> 生命力 1.0

> 魔力 2.2-2.1=0.1 

> 负面属性

> ~~魔力 2.1~~

> 力量 0.1

## 交换率

对于材料的加法，是符合交换率，材料a和材料b和材料c的加法

```csharp
a+b+c=a+c+b
```

两个材料相加，返回的是新材料，所以可以和其他材料相加。

```csharp
a+b+c=(a+b)+c
```

现在还需要做一些定义，一个材料只有正面属性生效。材料的负面属性只是在遇到另一个材料，而且刚好这个材料的正面属性存在属性和他的负面属性相同，才会把负面属性拿出来让材料的正面属性减去。

从上面的定义可以推出，任何的材料不会同时有一个属性存在正面属性集合和负面属性集合。

一个材料的正面属性集合可以有很多个属性值。

材料的正面属性集合的属性的属性值可能是负数。如两个材料相加，材料1的正面属性刚好和材料2的负面属性相同，而且材料1的属性值很小，这时两个材料相加，新的材料就会出现一个属性值为负数。

对于一个材料的负面属性值是否一定要求是正数还没定义，但是从炼药师的题目，是不能存在负数的。因为负面的属性是不会生效，那么如果一个负面属性值是负数，在一个材料的正面属性和这个材料的负面属性相同，反而会加大材料的正面属性值。

## 代码

现在还看不错来这个模型的意义，需要来写一点代码让大家比较容易看。

```csharp
    class 材料
    {
        public List<属性> 正面List { set; get; }=new List<属性>();
        public List<属性> 反向List { set; get; }=new List<属性>();
    }

    class 属性
    {
        public string 属性名 { get; set; }

        public double 属性值 { get; set; }
    }
```

代码定义很简单，因为我把变量都写中文，这样即使不会 C# 也大概可以看懂。

然后重新重写加法计算

```csharp
        public static 材料 Add(材料 材料1, 材料 材料2)
        {
            var 材料3 = new 材料();
            材料3.正面List.AddRange(材料1.正面List);
            材料3.正面List.AddRange(材料2.正面List);

            材料3.反向List.AddRange(材料1.反向List);
            材料3.反向List.AddRange(材料2.反向List);

            foreach (var 属性 in 材料3.正面List)
            {
                var temp = 材料3.反向List.Find(t => t.属性名 == 属性.属性名);
                if (temp != null)
                {
                    属性.属性值 -= temp.属性值;
                    材料3.反向List.Remove(temp);
                }
            }

            return 材料3;
        }

```

现在来把上面的测试写一下

```csharp
          var 材料1 = new 材料()
            {
                正面List = new List<属性>()
                {
                    new 属性("生命力", 1.0)
                },
                反向List = new List<属性>()
                {
                    new 属性("魔力", 2.1)
                }
            };

            var 材料2 = new 材料()
            {
                正面List = new List<属性>()
                {
                    new 属性("魔力", 2.2)
                },
                反向List = new List<属性>()
                {
                    new 属性("力量", 0.1)
                }
            };
```

因为需要输出一下值，所以再写一些代码

```csharp
      public override string ToString()
        {
            var str = new StringBuilder();
            str.Append("正面属性\r\n");

            foreach (var temp in 正面List)
            {
                str.Append(temp.属性名 + " " + temp.属性值.ToString("0.00") + "\r\n");
            }

            str.Append("负面属性\r\n");

            foreach (var temp in 反向List)
            {
                str.Append(temp.属性名 + " " + temp.属性值.ToString("0.00") + "\r\n");
            }

            return str.ToString();
        }
```

现在尝试调用添加两个材料，然后看一下输出

```csharp
            var 材料3 = 材料.Add(材料1, 材料2);

            Console.WriteLine("材料3");

            Console.WriteLine(材料3.ToString());
```

运行代码，可以看到输出

```csharp
材料3
正面属性
生命力 1.00
魔力 0.10
负面属性
力量 0.10

```

和刚才的计算的值一样。

## 定义属性

刚才的属性还不够多，在属性足够多的时候才可以进行这个计算。



为什么我会写这样的模型，我不是在做游戏，是在看人工智能的时候，准备使用一个超实数的方法去计算，所以才提出了这个算法，我尝试使用多个方式进行计算，发现使用沙堆模型才可能做出一个有思维的人工智能。

我在很久的时间都会想超实数的计算，我学到的数学很难描述这个复杂的人工智能，所以就自己定义计算的方法。

## 人工智能

我在输入的节点 1 和节点 2 ，两个节点输出到节点 3 ，这时的 节点 3 需要拿到哪些输入

尝试使用沙堆模型，对节点3的输入就是使用沙堆模型的计算方法，节点1和节点2都是有正面属性和负面属性。